<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Process Withdrawals | CryptoPay</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .admin-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .admin-header {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .pending-withdrawals {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }
        
        .withdrawal-item {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            background: #f9fafb;
        }
        
        .withdrawal-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .withdrawal-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }
        
        .info-value {
            font-weight: 600;
            color: #1f2937;
        }
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .btn-execute {
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn-execute:hover {
            background: #059669;
        }
        
        .btn-reject {
            background: #ef4444;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .btn-reject:hover {
            background: #dc2626;
        }
        
        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-pending {
            background: #fef3c7;
            color: #92400e;
        }
        
        .status-executed {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status-rejected {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .wallet-connection {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .loading-state {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
        }
        
        .no-withdrawals {
            text-align: center;
            padding: 3rem;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <div class="admin-header">
            <h1><i class="fas fa-cog"></i> Admin Dashboard</h1>
            <p>Process pending INR → Crypto withdrawals</p>
        </div>
        
        <div class="wallet-connection">
            <div id="wallet-status-container">
                <span id="wallet-status" class="wallet-status disconnected">Not Connected</span>
                <span id="network-status" class="network-status">Sepolia Required</span>
                <button id="connect-wallet-btn" class="btn btn-primary">Connect Admin Wallet</button>
            </div>
        </div>
        
        <div class="pending-withdrawals">
            <h2><i class="fas fa-list"></i> Pending Withdrawals</h2>
            <div id="withdrawals-container">
                <div class="loading-state">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading pending withdrawals...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <!-- Web3 and Contract Files -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
    <script src="js/contract-config.js"></script>
    <script src="js/contract-abi.js"></script>
    <script src="js/bxc-token-abi.js"></script>
    <script src="js/web3.js"></script>
    <script src="js/network-enforcer.js"></script>

    <!-- Configuration -->
    <script src="config.js"></script>

    <script>
        // Disable background transaction monitoring in admin page to reduce noise
        window.DISABLE_TX_MONITORING = true;
        // Silence user-specific Firestore updates on admin page
        (function(){
            const initOverride = () => {
                if (window.web3Manager) {
                    window.web3Manager.setCurrentUser(null);
                    // No-op balance updates and transaction logs in admin context
                    window.web3Manager.updateUserCryptoBalance = async () => {};
                    window.web3Manager.logTransaction = async () => {};
                } else {
                    setTimeout(initOverride, 200);
                }
            };
            initOverride();
        })();
        
        // Extract a human-readable revert reason from various provider error shapes
        function getRevertMessage(error) {
            try {
                if (!error) return 'Unknown error';
                if (typeof error === 'string') return error;
                if (error.message) return error.message;
                if (error.reason) return error.reason;
                if (error.data) {
                    if (typeof error.data === 'string') return error.data;
                    if (error.data.message) return error.data.message;
                    if (error.data.reason) return error.data.reason;
                    if (error.data.originalError?.message) return error.data.originalError.message;
                }
                if (error.originalError?.message) return error.originalError.message;
            } catch (e) {}
            return 'execution reverted';
        }
        class AdminWithdrawals {
            constructor() {
                this.pendingWithdrawals = [];
                this.ownerAddress = null;
                this.isPaused = false;
                // Default: don't call paused() to avoid one-time revert on non-Pausable deployments
                this.supportsPausedCheck = false;
                this.init();
            }

            async init() {
                try {
                    // Initialize Web3
                    if (window.web3Manager) {
                        await window.web3Manager.init();
                    }
                    
                    this.setupEventListeners();
                    await this.loadContractOwner();
                    if (this.supportsPausedCheck) {
                        await this.loadPausedStatus();
                    } else {
                        // Show UNKNOWN badge without calling the chain
                        const header = document.querySelector('.admin-header h1');
                        if (header) {
                            const badgeId = 'pause-badge';
                            let badge = document.getElementById(badgeId);
                            if (!badge) {
                                badge = document.createElement('span');
                                badge.id = badgeId;
                                badge.style.marginLeft = '10px';
                                badge.style.fontSize = '0.8rem';
                                badge.style.padding = '0.25rem 0.5rem';
                                badge.style.borderRadius = '6px';
                                header.appendChild(badge);
                            }
                            badge.textContent = 'UNKNOWN';
                            badge.style.background = '#e5e7eb';
                            badge.style.color = '#374151';
                        }
                    }
                    await this.loadPendingWithdrawals();
                    this.updateWalletStatus();
                } catch (error) {
                    console.error('Initialization error:', error);
                }
            }

            setupEventListeners() {
                document.getElementById('connect-wallet-btn').addEventListener('click', () => this.connectWallet());
                
                // Refresh every 30 seconds
                setInterval(() => this.loadPendingWithdrawals(), 30000);
            }

            async loadContractOwner() {
                try {
                    if (window.web3Manager?.contract) {
                        this.ownerAddress = await window.web3Manager.contract.methods.owner().call();
                        // Show owner in UI
                        const header = document.querySelector('.admin-header p');
                        if (header && this.ownerAddress) {
                            header.innerHTML = `Process pending INR → Crypto withdrawals<br/>Contract Owner: <code>${this.ownerAddress}</code>`;
                        }
                    }
                } catch (e) {
                    console.error('Failed to load contract owner:', e);
                }
            }

            async loadPausedStatus() {
                try {
                    if (!this.supportsPausedCheck) {
                        return;
                    }
                    if (window.web3Manager?.contract?.methods?.paused) {
                        this.isPaused = await window.web3Manager.contract.methods.paused().call();
                        const header = document.querySelector('.admin-header h1');
                        if (header) {
                            const badgeId = 'pause-badge';
                            let badge = document.getElementById(badgeId);
                            if (!badge) {
                                badge = document.createElement('span');
                                badge.id = badgeId;
                                badge.style.marginLeft = '10px';
                                badge.style.fontSize = '0.8rem';
                                badge.style.padding = '0.25rem 0.5rem';
                                badge.style.borderRadius = '6px';
                                header.appendChild(badge);
                            }
                            if (this.isPaused) {
                                badge.textContent = 'PAUSED';
                                badge.style.background = '#fecaca';
                                badge.style.color = '#7f1d1d';
                            } else {
                                badge.textContent = 'ACTIVE';
                                badge.style.background = '#bbf7d0';
                                badge.style.color = '#14532d';
                            }
                        }
                    }
                } catch (e) {
                    // If the contract doesn't implement paused(), mark unsupported and show UNKNOWN once
                    this.supportsPausedCheck = false;
                    const header = document.querySelector('.admin-header h1');
                    if (header) {
                        const badgeId = 'pause-badge';
                        let badge = document.getElementById(badgeId);
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.id = badgeId;
                            badge.style.marginLeft = '10px';
                            badge.style.fontSize = '0.8rem';
                            badge.style.padding = '0.25rem 0.5rem';
                            badge.style.borderRadius = '6px';
                            header.appendChild(badge);
                        }
                        badge.textContent = 'UNKNOWN';
                        badge.style.background = '#e5e7eb';
                        badge.style.color = '#374151';
                    }
                }
            }

            async connectWallet() {
                try {
                    if (window.web3Manager) {
                        await window.web3Manager.connectWallet();
                        this.updateWalletStatus();
                        this.showNotification('Admin wallet connected successfully!', 'success');
                    } else {
                        this.showNotification('Web3 not available. Please refresh the page.', 'error');
                    }
                } catch (error) {
                    console.error('Wallet connection error:', error);
                    this.showNotification('Failed to connect wallet', 'error');
                }
            }

            updateWalletStatus() {
                const walletStatus = document.getElementById('wallet-status');
                const networkStatus = document.getElementById('network-status');
                const connectBtn = document.getElementById('connect-wallet-btn');
                
                if (window.web3Manager && window.web3Manager.isConnected) {
                    walletStatus.textContent = `Connected: ${window.web3Manager.userAccount.slice(0, 6)}...${window.web3Manager.userAccount.slice(-4)}`;
                    walletStatus.className = 'wallet-status connected';
                    networkStatus.textContent = window.web3Manager.getNetworkStatus();
                    connectBtn.style.display = 'none';
                    // Warn if not owner
                    if (this.ownerAddress && window.web3Manager.userAccount.toLowerCase() !== this.ownerAddress.toLowerCase()) {
                        this.showNotification('Connected wallet is NOT the contract owner. Execution will fail.', 'warning');
                    }
                } else {
                    walletStatus.textContent = 'Not Connected';
                    walletStatus.className = 'wallet-status disconnected';
                    networkStatus.textContent = 'Sepolia Required';
                    connectBtn.style.display = 'inline-block';
                }
            }

            async loadPendingWithdrawals() {
                try {
                    const container = document.getElementById('withdrawals-container');
                    container.innerHTML = `
                        <div class="loading-state">
                            <i class="fas fa-spinner fa-spin"></i>
                            <p>Loading pending withdrawals...</p>
                        </div>
                    `;

                    const snapshot = await db.collection('pending_withdrawals')
                        .where('status', '==', 'pending_admin_execution')
                        .get();

                    this.pendingWithdrawals = [];
                    snapshot.forEach(doc => {
                        this.pendingWithdrawals.push({ id: doc.id, ...doc.data() });
                    });

                    // Sort client-side to avoid requiring a Firestore composite index
                    this.pendingWithdrawals.sort((a, b) => {
                        const aTime = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
                        const bTime = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
                        return bTime - aTime; // Descending
                    });

                    this.renderWithdrawals();
                } catch (error) {
                    console.error('Error loading pending withdrawals:', error);
                    document.getElementById('withdrawals-container').innerHTML = `
                        <div class="no-withdrawals">
                            <i class="fas fa-exclamation-triangle"></i>
                            <h3>Error loading withdrawals</h3>
                            <p>Unable to load pending withdrawals. Please try again later.</p>
                        </div>
                    `;
                }
            }

            renderWithdrawals() {
                const container = document.getElementById('withdrawals-container');
                
                if (this.pendingWithdrawals.length === 0) {
                    container.innerHTML = `
                        <div class="no-withdrawals">
                            <i class="fas fa-check-circle"></i>
                            <h3>No pending withdrawals</h3>
                            <p>All withdrawal requests have been processed.</p>
                        </div>
                    `;
                    return;
                }

                let html = '';
                const isOwner = this.ownerAddress && window.web3Manager?.userAccount && (this.ownerAddress.toLowerCase() === window.web3Manager.userAccount.toLowerCase());
                this.pendingWithdrawals.forEach(withdrawal => {
                    const createdAt = withdrawal.createdAt.toDate();
                    const formattedDate = createdAt.toLocaleString();
                    const shouldDisable = (this.supportsPausedCheck && this.isPaused) || !isOwner;
                    const disabled = shouldDisable ? 'disabled' : '';
                    const disabledTitle = shouldDisable ? `title="${!isOwner ? 'Connect the contract owner wallet' : 'Contract is paused'}"` : '';
                    
                    html += `
                        <div class="withdrawal-item">
                            <div class="withdrawal-header">
                                <h3>INR → ${withdrawal.crypto} Withdrawal</h3>
                                <span class="status-badge status-${withdrawal.status.replace(/_/g, '-')}">${withdrawal.status.replace(/_/g, ' ').toUpperCase()}</span>
                            </div>
                            <div class="withdrawal-info">
                                <div class="info-item">
                                    <span class="info-label">User ID</span>
                                    <span class="info-value">${withdrawal.userId}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">User Address</span>
                                    <span class="info-value">${withdrawal.userAddress}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">INR Amount</span>
                                    <span class="info-value">₹${withdrawal.inrAmount.toLocaleString()}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Crypto Amount</span>
                                    <span class="info-value">${withdrawal.cryptoAmount.toFixed(8)} ${withdrawal.crypto}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Token Address</span>
                                    <span class="info-value">${withdrawal.tokenAddress}</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Created At</span>
                                    <span class="info-value">${formattedDate}</span>
                                </div>
                            </div>
                            <div class="action-buttons">
                                <button class="btn-execute" ${disabled} ${disabledTitle} onclick="adminWithdrawals.executeWithdrawal('${withdrawal.id}')">
                                    <i class="fas fa-check"></i> Execute Withdrawal
                                </button>
                                <button class="btn-reject" onclick="adminWithdrawals.rejectWithdrawal('${withdrawal.id}')">
                                    <i class="fas fa-times"></i> Reject
                                </button>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            async executeWithdrawal(withdrawalId) {
                try {
                    if (!window.web3Manager || !window.web3Manager.isConnected) {
                        this.showNotification('Please connect admin wallet first', 'error');
                        return;
                    }

                    const withdrawal = this.pendingWithdrawals.find(w => w.id === withdrawalId);
                    if (!withdrawal) {
                        this.showNotification('Withdrawal not found', 'error');
                        return;
                    }

                    // Ensure connected wallet is the contract owner
                    if (!this.ownerAddress) {
                        await this.loadContractOwner();
                    }
                    if (this.ownerAddress && window.web3Manager.userAccount.toLowerCase() !== this.ownerAddress.toLowerCase()) {
                        this.showNotification('Connect the contract owner wallet to execute withdrawals', 'error');
                        return;
                    }

                    this.showNotification('Executing withdrawal...', 'info');
                    console.log('[Admin] Attempting executeWithdrawalTo', {
                        connected: window.web3Manager.userAccount,
                        owner: this.ownerAddress,
                        token: withdrawal.tokenAddress,
                        crypto: withdrawal.crypto,
                        cryptoAmount: withdrawal.cryptoAmount,
                        inrAmount: withdrawal.inrAmount,
                        supportsPausedCheck: this.supportsPausedCheck,
                        isPaused: this.isPaused
                    });

                    // Convert amount to Wei
                    const amountInWei = window.web3Manager.web3.utils.toWei(withdrawal.cryptoAmount.toString(), 'ether');

                    // Pre-check: token must be supported by contract
                    const supported = [CONTRACT_CONFIG.contracts.usdt.toLowerCase(), CONTRACT_CONFIG.contracts.bxc.toLowerCase()];
                    if (!supported.includes((withdrawal.tokenAddress || '').toLowerCase())) {
                        this.showNotification('Unsupported token address for withdrawal', 'error');
                        return;
                    }

                    // Pre-check: ensure contract has enough token balance
                    const erc20 = new window.web3Manager.web3.eth.Contract(window.web3Manager.getERC20ABI(), withdrawal.tokenAddress);
                    const contractTokenBal = await erc20.methods.balanceOf(CONTRACT_CONFIG.contracts.cryptoWallet).call();
                    const hasEnough = window.web3Manager.web3.utils.toBN(contractTokenBal).gte(window.web3Manager.web3.utils.toBN(amountInWei));
                    if (!hasEnough) {
                        const humanBal = window.web3Manager.web3.utils.fromWei(contractTokenBal, 'ether');
                        this.showNotification(`Insufficient contract token balance. Available: ${humanBal}`, 'error');
                        return;
                    }

                    // Pre-flight call to detect revert reasons before sending a transaction
                    try {
                        await window.web3Manager.contract.methods.executeWithdrawalTo(
                            withdrawal.userAddress,
                            withdrawal.tokenAddress,
                            amountInWei
                        ).call({ from: window.web3Manager.userAccount });
                    } catch (simErr) {
                        const msg = getRevertMessage(simErr).toLowerCase();
                        if (msg.includes('caller is not the owner')) {
                            this.showNotification('Only contract owner can execute withdrawals', 'error');
                        } else if (msg.includes('paused')) {
                            this.showNotification('Contract is paused. Unpause before executing.', 'error');
                        } else if (msg.includes('insufficient')) {
                            this.showNotification('Insufficient contract token balance', 'error');
                        } else if (msg.includes('unsupported token')) {
                            this.showNotification('Unsupported token address', 'error');
                        } else {
                            this.showNotification(`Execution would revert: ${msg}`, 'error');
                        }
                        return;
                    }

                    // Call executeWithdrawalTo function
                    const tx = await window.web3Manager.contract.methods.executeWithdrawalTo(
                        withdrawal.userAddress,
                        withdrawal.tokenAddress,
                        amountInWei
                    ).send({ from: window.web3Manager.userAccount });

                    console.log('Withdrawal executed successfully:', tx);

                    // Update withdrawal status in Firestore
                    await db.collection('pending_withdrawals').doc(withdrawalId).update({
                        status: 'executed',
                        executedAt: new Date(),
                        txHash: tx.transactionHash,
                        executedBy: window.web3Manager.userAccount
                    });

                    // Log in transactions collection for user's history
                    await db.collection('transactions').add({
                        userId: withdrawal.userId,
                        type: 'withdrawal',
                        currency: withdrawal.crypto,
                        amount: withdrawal.cryptoAmount,
                        inrAmount: withdrawal.inrAmount,
                        status: 'completed',
                        timestamp: new Date(),
                        txHash: tx.transactionHash,
                        toAddress: withdrawal.userAddress,
                        description: `INR to ${withdrawal.crypto} withdrawal`
                    });

                    this.showNotification('Withdrawal executed successfully!', 'success');
                    await this.loadPendingWithdrawals();

                } catch (error) {
                    const msg = getRevertMessage(error);
                    console.error('Withdrawal execution error:', { error, message: msg });
                    this.showNotification(`Failed to execute withdrawal: ${msg}`, 'error');
                }
            }

            async rejectWithdrawal(withdrawalId) {
                try {
                    const withdrawal = this.pendingWithdrawals.find(w => w.id === withdrawalId);
                    if (!withdrawal) {
                        this.showNotification('Withdrawal not found', 'error');
                        return;
                    }

                    // Update withdrawal status
                    await db.collection('pending_withdrawals').doc(withdrawalId).update({
                        status: 'rejected',
                        rejectedAt: new Date(),
                        rejectedBy: window.web3Manager?.userAccount || 'admin'
                    });

                    // Refund INR to user
                    const userDoc = await db.collection('users').doc(withdrawal.userId).get();
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        const newInrBalance = (userData.inrBalance || 0) + withdrawal.inrAmount;
                        
                        await db.collection('users').doc(withdrawal.userId).update({
                            inrBalance: newInrBalance,
                            updatedAt: new Date()
                        });
                    }

                    this.showNotification('Withdrawal rejected and INR refunded', 'success');
                    await this.loadPendingWithdrawals();

                } catch (error) {
                    console.error('Withdrawal rejection error:', error);
                    this.showNotification('Failed to reject withdrawal: ' + error.message, 'error');
                }
            }

            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    z-index: 1000;
                    max-width: 300px;
                `;
                notification.textContent = message;

                document.body.appendChild(notification);

                // Remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.adminWithdrawals = new AdminWithdrawals();
        });
    </script>
</body>
</html>
